"""Jira REST API v3 client for pushing security requirements as issues."""

import logging
from base64 import b64encode

import httpx

logger = logging.getLogger(__name__)


class JiraClient:
    def __init__(self, base_url: str, email: str, api_token: str):
        self.base_url = base_url.rstrip("/")
        auth = b64encode(f"{email}:{api_token}".encode()).decode()
        self.headers = {
            "Authorization": f"Basic {auth}",
            "Content-Type": "application/json",
            "Accept": "application/json",
        }

    async def create_issue(self, project_key: str, summary: str, description: str, issue_type: str = "Task", priority: str = "Medium", labels: list[str] | None = None) -> dict:
        payload = {
            "fields": {
                "project": {"key": project_key},
                "summary": summary,
                "description": {
                    "type": "doc",
                    "version": 1,
                    "content": [{"type": "paragraph", "content": [{"type": "text", "text": description}]}],
                },
                "issuetype": {"name": issue_type},
            }
        }
        if labels:
            payload["fields"]["labels"] = labels

        async with httpx.AsyncClient(timeout=30) as client:
            resp = await client.post(f"{self.base_url}/rest/api/3/issue", json=payload, headers=self.headers)
            resp.raise_for_status()
            data = resp.json()
            logger.info("Created Jira issue: %s", data.get("key"))
            return data

    async def add_comment(self, issue_key: str, body: str) -> dict:
        """Add a comment to an existing Jira issue."""
        payload = {
            "body": {
                "type": "doc",
                "version": 1,
                "content": [{"type": "paragraph", "content": [{"type": "text", "text": body}]}],
            }
        }
        async with httpx.AsyncClient(timeout=30) as client:
            resp = await client.post(
                f"{self.base_url}/rest/api/3/issue/{issue_key}/comment",
                json=payload,
                headers=self.headers,
            )
            resp.raise_for_status()
            data = resp.json()
            logger.info("Added comment to Jira issue: %s", issue_key)
            return data

    async def publish_analysis_to_issue(self, issue_key: str, analysis: dict) -> dict:
        """Publish analysis results as a formatted comment on an existing issue."""
        risk_score = analysis.get("risk_score", 0)
        abuse_cases = analysis.get("abuse_cases", [])
        requirements = analysis.get("security_requirements", [])
        stride_threats = analysis.get("stride_threats", [])

        # Build formatted comment
        lines = [
            "â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•",
            "ðŸ›¡ï¸ SECUREREQ AI - SECURITY ANALYSIS",
            "â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•",
            "",
            f"ðŸ“Š RISK SCORE: {risk_score}/100",
            "",
        ]

        if abuse_cases:
            lines.append("âš ï¸ ABUSE CASES IDENTIFIED:")
            lines.append("â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€")
            for i, ac in enumerate(abuse_cases, 1):
                lines.append(f"{i}. {ac.get('threat', 'Unknown')}")
                lines.append(f"   â€¢ Actor: {ac.get('actor', 'N/A')}")
                lines.append(f"   â€¢ Impact: {ac.get('impact', 'N/A')}")
                lines.append(f"   â€¢ Likelihood: {ac.get('likelihood', 'N/A')}")
                lines.append(f"   â€¢ STRIDE: {ac.get('stride_category', 'N/A')}")
                lines.append(f"   â€¢ Attack Vector: {ac.get('attack_vector', 'N/A')}")
                lines.append("")

        if requirements:
            lines.append("ðŸ›¡ï¸ SECURITY REQUIREMENTS:")
            lines.append("â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€")
            for req in requirements:
                lines.append(f"â€¢ [{req.get('priority', 'Medium')}] {req.get('id', '')}: {req.get('text', '')}")
            lines.append("")

        if stride_threats:
            lines.append("ðŸ“Š STRIDE THREAT ANALYSIS:")
            lines.append("â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€")
            for st in stride_threats:
                lines.append(f"â€¢ [{st.get('category', '')}] {st.get('threat', '')} - Risk: {st.get('risk_level', 'N/A')}")
            lines.append("")

        lines.append("â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€")
        lines.append("Generated by SecureReq AI")

        comment_body = "\n".join(lines)
        return await self.add_comment(issue_key, comment_body)

    async def push_analysis(self, project_key: str, issue_type: str, abuse_cases: list[dict], requirements: list[dict]) -> list[dict]:
        created = []
        for ac in abuse_cases:
            desc = f"Threat Actor: {ac.get('actor', 'N/A')}\nAttack Vector: {ac.get('attack_vector', 'N/A')}\nImpact: {ac.get('impact', 'N/A')}\nLikelihood: {ac.get('likelihood', 'N/A')}\nSTRIDE: {ac.get('stride_category', 'N/A')}\n\n{ac.get('description', '')}"
            result = await self.create_issue(project_key, f"[Abuse Case] {ac.get('threat', '')}", desc, issue_type, labels=["security", "abuse-case"])
            created.append(result)

        for req in requirements:
            desc = f"Priority: {req.get('priority', 'N/A')}\nCategory: {req.get('category', 'N/A')}\n\n{req.get('text', '')}\n\nDetails: {req.get('details', '')}"
            result = await self.create_issue(project_key, f"[Security Req] {req.get('id', '')} - {req.get('text', '')[:80]}", desc, issue_type, labels=["security", "requirement"])
            created.append(result)

        return created
